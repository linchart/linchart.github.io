[{"title":"TF-IDF原理及应用","date":"2017-03-15T09:36:24.153Z","path":"posts/2017/03/15/TF-IDF.html","text":"你说广州塔，我知道是在广州，你说黄果树瀑布，我知道是在贵州，你说布达拉宫，我知道是在拉萨，你说公交车，我都不知道你在说哪个城市的公交车。这就是TF-IDF。 概念及原理TF-IDF全称Term Frequency and Inverse Document Frequency，直译过来就是’词频-逆向文件频率’，’TF’是指某一个给定的词语在该文件中出现的频率，’IDF’是指总文件数除以包含该词的文件数，再取对数。TF-IDF一般用来评估在一堆语料库或一堆文件集中，某个字词对于该语料库或该文件的重要程度。怎么理解呢，举个例子，假设现在手上有10篇文章，‘水果’这个词在某一篇文章出现的频率很高，但是在这10篇文章中的仅有2篇文章提到，那么‘水果’这个词的TF-IDF会很高，如果10篇文章中有8篇提到‘水果’这个词，那么这个词的‘TF-IDF’会相对偏低。主要思想就是，一个词越能将一篇文章与其他文章区分开来，那么这个词的权重越高。 计算公式TF计算： （markdown编辑数学公式还不怎么熟，先用mathtype搞好再截图吧）比如上面的例子，’水果’，’硬盘’在文章1中出现的次数分别为2次，4次，那么:12TF(水果) = 2/10 = 0.2 TF(硬盘) = 4/10 = 0.4 IDF计算： 如果这10篇文章中，有2篇文章包含有’水果’这个词，有5篇包含’硬盘’这个词，那么：12IDF(水果) = log(10/2) = 1.6094 IDF(硬盘) = log(10/5) = 0.6931 TF-IDF计算算好TF和IDF之后，就可以计算’水果’和’硬盘’的TF-IDF了，只需要将TF和IDF相乘就ok。所以’水果’的TF-IDF为：10.2*1.6094 ‘硬盘’的TF-IDF为：10.4*0.6931 如果算’水果’和’硬盘’这两个词与文章1的相关性呢，很简单，只要将这两个词的TF-IDF加起来。10.2*1.6094 + 0.4*0.6931 python中计算TF-IDF使用的工具 jieba scikit-learn 切词其实切词只是计算TF-IDF的前期准备工作，在对中文文本进行TF-IDF计算的话，切词这一步应该是怎么也逃不过去了。平常工作中基本都是用jieba切词，这里也打算用jieba对文本进行处理。例如我现在有5个文本：1content = [['萨德系统核心装备X波段雷达'],['美韩当局部署萨德的步伐也在加速进行'],['纵观如今的手机处理器市场已经不是高通一家独大的局面'],['三星的Exynos处理器以及华为的海思麒麟芯片这些年风头正盛'],['魅族每年数以千万计的销量对于芯片厂商的贡献也是不可小看的']] 首先需要对文本进行切词，切词代码及结果如下：1234567891011def cut_words(text): results = [] for content in contents: seg_list = jieba.cut(content[0],cut_all=False) # 实际应用过程中，这里需要去除停用词 seg = ' '.join(seg_list) results.append(seg) return resultsresult = cut_words(contents)result = ['萨德 系统核心 装备 X 波段 雷达', '美韩 当局 部署 萨德 的 步伐 也 在 加速 进行', '纵观 如今 的 手机 处理器 市场 已经 不是 高通 一家独大 的 局面', '三星 的 Exynos 处理器 以及 华为 的 海思 麒麟 芯片 这些 年 风头 正 盛', '魅族 每年 数以千万计 的 销量 对于 芯片 厂商 的 贡献 也 是 不可 小看 的'] 准备工作做好之后，我们就可以进行TF-IDF计算了。 词语转矩阵词语转矩阵需要用到CountVectorizer这个函数，其作用是统计词汇的数量，并转为矩阵。1234#coding:utf-8from sklearn.feature_extraction.text import CountVectorizervectorizer = CountVectorizer()vector_location = vectorizer.fit_transform(result) 通过type(vector_location)可以看到，函数fit_transform把result二维数组表示成一个稀疏矩阵:123print(type(vector_location))#输出&lt;class 'scipy.sparse.csr.csr_matrix'&gt; 同时可以看下，vercot_location的输出结果：1234567891011121314151617181920212223242526272829303132333435363738394041424344print(vector_location)#输出#(0, 27) 1#(0, 23) 1#(0, 28) 1#(0, 21) 1#(0, 34) 1#(1, 27) 1#(1, 25) 1#(1, 16) 1#(1, 32) 1#(1, 19) 1#(1, 6) 1#(1, 31) 1#(2, 24) 1#(2, 10) 1#(2, 17) 1#(2, 9) 1#(2, 15) 1#(2, 14) 1#(2, 4) 1#(2, 36) 1#(2, 1) 1#(2, 13) 1#(3, 9) 1#(3, 2) 1#(3, 0) 1#(3, 5) 1#(3, 7) 1#(3, 22) 1#(3, 38) 1#(3, 26) 1#(3, 30) 1#(3, 35) 1#(4, 26) 1#(4, 37) 1#(4, 20) 1#(4, 18) 1#(4, 33) 1#(4, 11) 1#(4, 8) 1#(4, 29) 1#(4, 3) 1#(4, 12) 1 输出结果表示的是这个稀疏矩阵的第几行第几列有值，比如(0, 27) 1表示矩阵的第0行第27列有值。转成矩阵的形式之后，我们就可以很容易地算出每个词对应的TF-IDF了，这里使用TfidfTransformer函数进行计算。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from sklearn.feature_extraction.text import TfidfTransformertransformer = TfidfTransformer()tf_idf = transformer.fit_transform(vector_location)print(type(tf_idf))#输出，同样是稀疏矩阵的形式#&lt;class 'scipy.sparse.csr.csr_matrix'&gt;print(tf_idf)#输出#(0, 34) 0.463693222732#(0, 21) 0.463693222732#(0, 28) 0.463693222732#(0, 23) 0.463693222732#(0, 27) 0.37410477245#(1, 31) 0.387756660106#(1, 6) 0.387756660106#(1, 19) 0.387756660106#(1, 32) 0.387756660106#(1, 16) 0.387756660106#(1, 25) 0.387756660106#(1, 27) 0.312839631859#(2, 13) 0.321896111462#(2, 1) 0.321896111462#(2, 36) 0.321896111462#(2, 4) 0.321896111462#(2, 14) 0.321896111462#(2, 15) 0.321896111462#(2, 9) 0.259703755905#(2, 17) 0.321896111462#(2, 10) 0.321896111462#(2, 24) 0.321896111462#(3, 35) 0.327880622184#(3, 30) 0.327880622184#(3, 26) 0.264532021474#(3, 38) 0.327880622184#(3, 22) 0.327880622184#(3, 7) 0.327880622184#(3, 5) 0.327880622184#(3, 0) 0.327880622184#(3, 2) 0.327880622184#(3, 9) 0.264532021474#(4, 12) 0.321896111462#(4, 3) 0.321896111462#(4, 29) 0.321896111462#(4, 8) 0.321896111462#(4, 11) 0.321896111462#(4, 33) 0.321896111462#(4, 18) 0.321896111462#(4, 20) 0.321896111462#(4, 37) 0.321896111462#(4, 26) 0.259703755905 做到这一步的话还差一点点，因为在实际应用过程中，我们还需要把稀疏矩阵转成平常用的行列形式的矩阵才方便使用。这里可以使用todense()或者toarray()函数，前者是将稀疏矩阵转成matrix的形式，后者是将稀疏矩阵转成ndarray的形式1234567weight = tf_idf.toarray()#orweight1 = tf_idf.todense()print(weight)#输出#(5,39) 其实print一下weight的shape可以看到，这是一个5行39列的数组，5代表5个文本，39代表切词并用于计算的词的数量。如果文本的数量很大，切出来的词有很多的话，你很有可能会遇到MemoryError的错误，比如有1万个文本，切词3万个，那么数组（矩阵）的大小就变成了(10000,30000)，这样就会变得极其稀疏。对于大数据量的文本在计算TF-IDF时遇到MemoryError时，除了加内存或者上服务器之外，目前尚未找到更好的解决办法。这里还有一个问题，就是我怎么知道每个权重对应的是哪个词呢？这里可以将词作为列名，将数组转成Dataframe进行查看。1234word=vectorizer.get_feature_names()df = pd.DataFrame(weight)df.columns = wordprint(df) 源代码最后照例附上本次分析的源代码123456789101112131415161718192021222324252627282930313233343536#coding:utf-8#author:linchartimport jiebaimport pandas as pdfrom sklearn.feature_extraction.text import CountVectorizerfrom sklearn.feature_extraction.text import TfidfTransformercontents = [['萨德系统核心装备X波段雷达'],\\ ['美韩当局部署萨德的步伐也在加速进行'],\\ ['纵观如今的手机处理器市场已经不是高通一家独大的局面'],\\ ['三星的Exynos处理器以及华为的海思麒麟芯片这些年风头正盛'],\\ ['魅族每年数以千万计的销量对于芯片厂商的贡献也是不可小看的']]def cut_words(text): results = [] for content in contents: seg_list = jieba.cut(content[0],cut_all=False) # 实际应用过程中，这里需要去除停用词 seg = ' '.join(seg_list) results.append(seg) return resultsdef tf_idf(words): vectorizer = CountVectorizer() vector_location = vectorizer.fit_transform(result) transformer = TfidfTransformer() tf_idf = transformer.fit_transform(vector_location) weight = tf_idf.toarray() word = vectorizer.get_feature_names() df = pd.DataFrame(weight) df.columns = word return dfresult = cut_words(contents)df = tf_idf(result)print(df)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"NLP","slug":"NLP","permalink":"http://yoursite.com/tags/NLP/"}]},{"title":"爬取微信文章（一）","date":"2017-03-13T09:59:18.349Z","path":"posts/2017/03/13/WeChat_Article1.html","text":"&emsp;&emsp;有时在微信公众号上面看到一些写的比较好的文章，但又没有时间细看，闲下来想找这些文章的时候又忘了是在哪个公众号看的了、文章名字也想不起来，因此想搞个爬虫把想看的文章爬下来，一来可以在闲时咀嚼一下，二来也可以收藏一些好文章，做些知识积累。只是想把自己平常做的一些东西记录下来，非教程 工具 Python 3.5.1 使用的库 re pdfkit requests BeautifulSoup 功能输入微信文章名称或者对应的文章链接，输出文章的pdf文件。 思路 如果同时提供文章链接和文章名称，则优先通过文章链接爬取，如果文章链接爬取失败，则通过文章名称爬取； 如果仅提供文章链接，则通过文章链接爬取； 如果仅提供文章名称，则通过搜狗微信接口搜索微信文章，找到对应文章链接，然后在通过文章链接爬取。 爬取流程获取文章链接将提供的文章名称传入搜狗微信搜索引擎搜索，将结果列表中的第一篇文章作为目标文章下载。下面代码返回目标文章链接。 12345678910111213def get_article_link(query): base_url = r'http://weixin.sogou.com/weixin' User_Agent = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36' Host = 'weixin.sogou.com' Connection = 'keep-alive' headers = &#123;'User-Agent': User_Agent, 'Host': Host, 'Connection': Connection&#125; params = &#123;'type': 2, 'ie': 'utf-8', 'w': '01019900', 'sut': '707','query':query&#125; request = requests.get(base_url, headers=headers, params=params) request.encoding = 'utf-8' bsobj = BeautifulSoup(request.text, 'lxml') # 仅提取列表中的第一篇文章 first_article_link = bsobj.select('#sogou_vr_11002601_title_0')[0]['href'] return first_article_link 将文章转为html解析文章链接，将文章内容保存为html文件。这里需要注意的是，在解析文章的时候，如果文章中包含有图片的话，正常情况下是无法下载下来的，因为爬取的文章链接为临时链接，非永久链接，无法直接解析src里面的链接。但是，data-src这个属性的值还是可以解析出来的，所以只要把data-src替换为src就可以下载图片了。 12345678910111213141516171819def get_article_html(link): # 为了保险起见，这里使用不同的headers User_Agent = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/3.0 Safari/536.11' article_headers = &#123;'User_Agent': User_Agent&#125; article_obj = requests.get(link, headers=article_headers) article_obj.encoding = 'utf-8' soup = BeautifulSoup(article_obj.content, 'html5lib') # 以实际的文章名称为准 article_name = soup.select('#activity-name')[0].text.strip() content = soup.find('div', &#123;'id': 'page-content'&#125;) html = str(content) # 把属性data-src替换成src,前面无法将属性src解析出来，data-src，只是LAZY用的， # 延迟加载图片所以显示不出来，LAZYLOAD src_compile = re.compile('data-src') html_new = re.sub(src_compile, 'src', html) # 存储成html with open('wechat_article.html', 'w', encoding='GB18030') as f: f.write(html_new) return article_name html转pdfhtml文件转pdf调用了pdfkit这个包，使用这个包需要安装wkhtmltopdf软件（pdfkit依赖于wkhtmltopdf，因此需要配置路径）。在运行过程中，发现pdfkit在html转pdf时，生成的pdf文件名中如果包含有| / *这些特殊符号时会报错，因此如果以原文章名对pdf命名失败时，仅保留文章名的汉字、字母和数字进行命名。 1234567891011121314151617def html_to_pdf(query_article): path_wk = r'D:\\Program Files\\wkhtmltopdf\\bin\\wkhtmltopdf.exe' config = pdfkit.configuration(wkhtmltopdf=path_wk) options = &#123; 'page-size': 'Letter', 'encoding': \"GB18030\", 'custom-header': [ ('Accept-Encoding', 'gzip') ] &#125; try : pdfkit.from_file('wechat_article.html', '%s.pdf' % query_article, configuration=config, options=options) except: name_compile = re.compile('[a-zA-Z\\u4e00-\\u9fa5][a-zA-Z0-9\\u4e00-\\u9fa5]+') pdf_name = re.findall(name_compile,query_article)[0] pdfkit.from_file('wechat_article.html', '%s.pdf' % pdf_name, configuration=config, options=options) print('文件名已被修改为:%s' %pdf_name) 源代码最后附上文章爬取的完整代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding:utf-8#author:linchartimport requestsfrom bs4 import BeautifulSoupimport reimport pdfkitdef get_article_link(query): base_url = r'http://weixin.sogou.com/weixin' User_Agent = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36' Host = 'weixin.sogou.com' Connection = 'keep-alive' headers = &#123;'User-Agent': User_Agent, 'Host': Host, 'Connection': Connection&#125; params = &#123;'type': 2, 'ie': 'utf-8', 'w': '01019900', 'sut': '707','query':query&#125; request = requests.get(base_url, headers=headers, params=params) request.encoding = 'utf-8' bsobj = BeautifulSoup(request.text, 'lxml') # 仅提取列表中的第一篇文章 first_article_link = bsobj.select('#sogou_vr_11002601_title_0')[0]['href'] return first_article_linkdef get_article_html(link): # 需要不同的headers User_Agent = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/3.0 Safari/536.11' article_headers = &#123;'User_Agent': User_Agent&#125; article_obj = requests.get(link, headers=article_headers) article_obj.encoding = 'utf-8' soup = BeautifulSoup(article_obj.content, 'html5lib') # 以实际的文章名称为准 article_name = soup.select('#activity-name')[0].text.strip() content = soup.find('div', &#123;'id': 'page-content'&#125;) html = str(content) # 把属性data-src替换成src,前面无法将属性src解析出来，data-src，只是LAZY用的， # 延迟加载图片所以显示不出来，LAZYLOAD src_compile = re.compile('data-src') html_new = re.sub(src_compile, 'src', html) # 存储成html with open('wechat_article.html', 'w', encoding='GB18030') as f: f.write(html_new) return article_namedef html_to_pdf(query_article): path_wk = r'D:\\Program Files\\wkhtmltopdf\\bin\\wkhtmltopdf.exe' config = pdfkit.configuration(wkhtmltopdf=path_wk) options = &#123; 'page-size': 'Letter', 'encoding': \"GB18030\", 'custom-header': [ ('Accept-Encoding', 'gzip') ] &#125; try : pdfkit.from_file('wechat_article.html', '%s.pdf' % query_article, configuration=config, options=options) except: name_compile = re.compile('[a-zA-Z\\u4e00-\\u9fa5][a-zA-Z0-9\\u4e00-\\u9fa5]+') pdf_name = re.findall(name_compile,query_article)[0] pdfkit.from_file('wechat_article.html', '%s.pdf' % pdf_name, configuration=config, options=options) print('文件名已被修改为:%s' %pdf_name)def wechat_article(query=None,link=None): if link : try : article_name = get_article_html(link) html_to_pdf(article_name) print('文章下载成功') except : article_link = get_article_link(query) get_article_html(article_link) html_to_pdf(query) print('文章下载成功') else : article_link = get_article_link(query) get_article_html(article_link) html_to_pdf(query) print('文章下载成功')# PDF可以用中文命名，但是命名中不可以包含* \\/|等特殊字符。if __name__ == '__main__': link = None query = '文本分析|词频与余弦相似度' wechat_article(query=query,link=link)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"博客的搭建","date":"2017-03-04T18:08:32.626Z","path":"posts/2017/03/05/blog.html","text":"参考文档这个博客的搭建，完全得益于教你免费搭建个人博客，Hexo&amp;Github和使用GitHub和Hexo搭建免费静态Blog这两篇文章，非常详细地描述了基于hexo+github搭建个人博客的准备工作及安装和配置流程。 遇到的问题虽然上面这两篇文章写得很详细，但是我在按着教程搭建的过程中还是遇到一些小问题，这里记录一下： 1、注意运行路径在浏览器中查看自带的hello world文章，需要执行 hexo generate 和hexo server两个命令，这里要注意一下这两个命令的执行路径，需要在hello world文章路径下执行。 2、MarkdownPad无法预览win10下首次安装MarkdownPad会出现右侧浏览页面无法浏览的情况，这种情况下需要安装Awesomium 1.6.6 SDK，安装完成之后问题可解决。 3、yilia主题头像无法显示若加载头像后，头像无法显示，需要将’themes/yilia/layout/_partial’路径下的文件left-col.ejs中的第6行修改为： &lt;img src=\"&lt;%=theme.avatar%&gt;\" class=\"js-avatar show\"&gt; 4、部署上传部署上传时执行以下命令时 hexo d 报’ERROR Deployer not found: git’错误，可能是deployer-git插件未安装，在根目录下执行下面代码安装该插件即可。 npm install hexo-deployer-git --save","tags":[]}]