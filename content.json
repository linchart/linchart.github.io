[{"title":"感知机模型","date":"2017-08-01T03:16:20.734Z","path":"posts/2017/08/01/perceptron_model.html","text":"&emsp;&emsp;刚从广发项目撤出来，未来几周应该都不会很忙，趁着闲暇时间整理一下机器学习方面的知识。&emsp;&emsp;先从最简单的感知机模型说起。感知机是一种二分类的线性模型，其假设训练数据集是线性可分的，目标是找到一个能够将训练数据集的正样本和负样本完全正确分割开的分离超平面。其实，模型只要找到该分离超平面，学习目的就达到了，并不要求样本能被最大限度地划分。 分类器&emsp;&emsp;分类器能够通过输入的特征向量映射到给定类别中的一个，也就是所谓的物以聚类人以群分。如下图一，蓝色直线将A和B完全分割开，那么该直线$y=ax+b$就是一个分类器。根据分类器是否线性可分的性质，分类器有线性分类器(图一)和非线性分类器（图二图三），从类别上，有二元分类器（图一）和多元分类器（两个类别以上，图二图三），而本章要讨论的感知机模型，就是一个二分类线性模型。 感知机模型&emsp;&emsp;感知机模型很简单，为什么说它简单呢，因为该模型只用了一个线性方程$y = ax + b$ 以及 一个符号函数$sign(x)$（初中的知识是不是？）&emsp;&emsp;下面来看下感知机模型的定义。&emsp;&emsp;假设有$N$维的特征输入$X = \\lbrace x_1,x_2,…,x_n \\rbrace $，输出的类别有两类$ Y = \\lbrace +1,-1\\rbrace $，则由特征输入映射到类别输出的函数$$f(x) = sign(w*x+b)$$称为感知机模型，其中，$w$ 和$b$是我们要求解的模型的参数，这里的$w$其实是一个跟特征输入维度一样$N$维的权值向量（也称为权重），而参数$b$为偏置（在二维平面上，$b$就是截距）。&emsp;&emsp;我们从公式上去解读下为什么说感知机模型是一个线性二分类模型。&emsp;&emsp;先看符号函数里面的线性方程$$y=w*x+b$$显然，方程$ y = w*x +b $在二维平面上是一条直线，在三维空间上是一个平面，在四维甚至更高维空间上就是一个超平面。（哈哈哈，这个实在是画不出来）也就是说，不管是在二维三维空间还是更高维空间，超平面都可以将空间一分为二，并且都可以表示成方程$ y = w*x +b $，所以感知机模型首先是一个线性模型。&emsp;&emsp;再看符号函数，这个更简单，符号函数的定义如下：$$sign(x)=\\begin{cases}+1,\\quad x\\geq 0\\\\-1, \\quad x&lt;0\\end{cases}$$ 如果$x&gt;=0$则$f(x)=+1$，否则$f(x)=-1$。那么对于函数$f(x) = sign(w*x+b)$，如果输入样本$w*x+b&gt;=0$，那么该样本会被判为+1类，否则判为-1类。举个例子，回到上文图一，对于直线上方有$w*x+b&gt;0$，所以所有的A样本都会归为+1类，对于直线下方有$w*x+b&lt;0$，这样所有的B样本都会归为-1类。因此，感知机模型是一个线性二分类模型，其任务就是，找到这样的一个超平面，能够把两个不同的分类完全分割开。 学习策略&emsp;&emsp;原理清楚了，那么现在的问题是，给定一个包含正负类的训练样本，我们应该如何找出这样的一个超平面，使之能够将正样例和负样例点完全分割开，也就是应该如何确定模型的参数$w$和$b$ &emsp;&emsp;如上图，如何找到一条直线，使之能够将蓝色实例和褐色实例分割开（这里只是举个例子哈，在实际构建模型过程中，涉及的数据动不动就成百上千万，你想拿支笔来，往两个样本点之间一画一条直线，这是妥妥的不行的，更何况实际处理的数据维度一般都有两位数以上）。直接求解好像无从下手，不妨先假设参数$w$和$b$已知，也就是说这个超平面$S$我们已经找到了，但是不知道这超平面对样例数据的分类效果怎样。如何去评估分类的效果呢，一个很自然的想法就是看有多少样例数据是误分类的，也就是将总误分类数作为模型的损失函数，但是这样的函数对于参数$w$和$b$来说不是连续可导的，难以优化。另一种方法就是可以通过衡量误分类点到超平面的总距离来评估效果。高中的时候我们就学过点到平面的距离的公式是这样子的。$$d=\\frac{|A*x_0+B*y_0+C*z_0+D|}{\\sqrt{A^2+B^2+C^2}}$$ 其中$(A,B,C)$是平面法向量，在这里是权值向量，上面距离公式也可以简写成$$d=\\frac{1}{||w||}|wx_0+b|$$ 其中$w=(A,B,C)$， 这里||w||也称为$w$的L2范数。依然以上文图一为例，对于任意一个样本点$(x_i,y_i)$: 如果该样本点是位于直线上方，并且刚好属于类别A的话，那么该样本点被直线正确分类，此时有$w*x_i+b&gt;0,y_i=+1$，显然$-y_i*(w*x_i+b)&lt;0$ 如果该样本点位于直线下方，并且刚好属于类别B的的话，那么该样本点被直线正确分类，此时有$w*x_i+b&lt;0,y_i=-1$，显然$-y_i*(w*x_i+b)&lt;0$ 如果该样本点位于直线上方，并且刚好属于类别B的的话，那么该样本点被直线错误分类，此时有$w*x_i+b&gt;0,y_i=-1$，显然$-y_i*(w*x_i+b)&gt;0$ 如果该样本点位于直线下方，并且刚好属于类别A的的话，那么该样本点被直线错误分类，此时有$w*x_i+b0$ &emsp;&emsp;所以，对于误分类的点$(x_i,y_i)$来说$-y_i*(w*x_i+b)&gt;0$成立。&emsp;&emsp;我们可以用$-y_i*(w*x_i+b)$（相当于$|w*x_i+b|$）去衡量误分类点的效果，$w*x_i+b$值越大，说明该点离分离超平面越远，误分类效果越差（虽然分错了就是分错了）。如下图中的红色直线对于点A的分类效果明显比点B的要差 有了单个误分类点离超平面的距离，那么对于所有的误分类点有：$$ -\\frac{1}{||w||}\\sum_i^m y_i(wx_i+b)$$ 其中$m$为误分类点数量。当不考虑$\\frac{1}{||w||}$时（$\\frac{1}{||w||}$恒大于0，去掉的话不影响评估效果），就得到感知机模型的损失函数$Loss Function$（用来度量模型预测的好坏）：$$ L(w,b) =-\\sum_i^m y_i(wx_i+b)$$既然误分类点离分离超平面越远，误分类效果越差，那么，误分类点离分离超平面越近，误分类效果越好，当$$-\\sum_i^m y_i(wx_i+b) = 0$$时，样本没有被误分类，所有样本都被超平面恰当地分割开。所以只要找到$w$和$b$使得$L(w,b)$取最小值，此时超平面的分类效果是最好的，这个时候我们可以将参数$w$和$b$的求解转化为最小化函数$L(w,b)$ $$minL(w,b) = -\\sum_i^m y_i(wx_i+b)$$ 算法实现&emsp;&emsp;最优化方法有很多，比如牛顿下降法、拉格朗日乘子法、共轭梯度下降法、梯度下降法，这里使用最简单也最常用的一样方法：随机梯度下降法（梯度下降法的一种方法）来优化上文提到的损失函数$L(w,b)$ $$L(w,b) = -\\sum_i^m y_i(wx_i+b)$$ 梯度其实就是求偏导，随机梯度下降其实就是一次随机选一个误分类点，使其函数值$L(w,b)$往着负梯度方向移动，不断逼近最小值的一个过程。函数$L(w,b)$关于参数$w$和$b$的梯度分别为：$$\\nabla_w L(w,b)= -\\sum_i^m y_i x_i $$ $$\\nabla_b L(w,b)= -\\sum_i^m y_i $$ 现在，我们随便找一个分割超平面，比如$w=0,b=0$（注意$w$是一个向量），然后随机选一个实例点，判断$-y_i*(w*x_i+b)$ 是否大于等于0，如果大于等于0则说明该点被误分类，这时对$(w,b)$进行如下更新（如果$-y_i*(w*x_i+b)$小于0则不更新$w$和$b$）：$$w \\leftarrow w+\\eta y_i x_i$$ $$b \\leftarrow b+\\eta y_i$$ 这里的$\\eta$$(0&lt;=\\eta&lt;=1)$为步长，也称为学习率，这样，通过不断选取误分类点，更新参数$(w,b)$，降低函数$L(w,b)$的值，直到$L(w,b)=0$时对应的$(w,b)$的取值就是要求解的值。算法很简单，分成4步，也就是： (1)选取初值$(w_0,b_0)$; (2)在训练数据集中随机选取一个数据$(x_i,y_i)$; (3)如果$-y_i*(w*x_i+b)&gt;=0$，则进行如下更新：$$w \\leftarrow w+\\eta y_i x_i$$ $$b \\leftarrow b+\\eta y_i$$ (4)转至(2)，直至数据集中没有误分类的点或者达到指定的迭代次数。 用python实现基于随机梯度下降的简单感知机模型。 import numpy as np import random import matplotlib.pyplot as plt %matplotlib inline from sklearn.datasets.samples_generator import make_blobs #随机生成特征维度为2，分别以[-1,-1],[1,1]为中心，类别方差为0.4,0.5的两个类 x,y = make_blobs(n_samples=100,n_features=2,centers=[[-1,-1],[1,1]],cluster_std=[0.4,0.5]) # 将 0 替换成-1 y[y==0] = -1 w = np.zeros(2)#初始权重赋值为0 b = 0 #初始偏置为0 k=200 #最大迭代次数 l_rate = 0.5 #学习率 i=0 while i &lt;= k: i = i+1 #生成随机数 random_num = random.randint(0,99) #损失函数 if sum(-y[random_num]*(w*x[random_num] + b)) &gt;= 0: #梯度更新权重 w = w + l_rate*y[random_num]*x[random_num] #梯度更新偏置 b = b + l_rate*y[random_num] #---------------------画图------------------------- x1 = -3.0 y1 = -(b + w[0] * x1) /w[1] x2 = 3.0 y2 = -(b + w[0] * x2) / w[1] plt.figure(figsize=(8, 6)) plt.plot([x1,x2],[y1,y2],'r') plt.scatter(x[:,0],x[:,1],marker='o',c=y,s=50) plt.xlabel('x1') plt.ylabel('x2') plt.show() &emsp;&emsp;因为这里的两个样本区分度太明显，所以经过几次迭代就已经收敛了。最终求得参数$w=[1.03972853 \\ 0.97360177] ,b=0$，根据参数$(w,b)$画出的直线如下图所示：完美地将两个不同的样本分隔开！ 后记&emsp;&emsp;感知机模型假设训练数据集是线性可分的，如果线性不可分，算法会一直震荡无法收敛，所以其无法处理一些复杂的数据，如在分类器中提到的图二和图三。考虑到实际业务的数据一般比较复杂，简单的感知机模型无法有效地处理如此复杂的数据，所以在建模中很少会使用该模型。但是感知机模型还是比较重要的，为什么这么说呢，因为只要稍微修改下模型的损失函数，感知机模型就可转变为广受欢迎的分类神器：支持向量机，而通过简单的堆叠可演变为神经网络模型。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"},{"name":"分类模型","slug":"分类模型","permalink":"http://yoursite.com/tags/分类模型/"},{"name":"监督学习","slug":"监督学习","permalink":"http://yoursite.com/tags/监督学习/"}]},{"title":"TF-IDF原理及应用","date":"2017-03-15T09:36:24.153Z","path":"posts/2017/03/15/TF-IDF.html","text":"你说广州塔，我知道是在广州，你说黄果树瀑布，我知道是在贵州，你说布达拉宫，我知道是在拉萨，你说公交车，我都不知道你在说哪个城市的公交车。这就是TF-IDF。 概念及原理TF-IDF全称Term Frequency and Inverse Document Frequency，直译过来就是’词频-逆向文件频率’，’TF’是指某一个给定的词语在该文件中出现的频率，’IDF’是指总文件数除以包含该词的文件数，再取对数。TF-IDF一般用来评估在一堆语料库或一堆文件集中，某个字词对于该语料库或该文件的重要程度。怎么理解呢，举个例子，假设现在手上有10篇文章，‘水果’这个词在某一篇文章出现的频率很高，但是在这10篇文章中的仅有2篇文章提到，那么‘水果’这个词的TF-IDF会很高，如果10篇文章中有8篇提到‘水果’这个词，那么这个词的‘TF-IDF’会相对偏低。主要思想就是，一个词越能将一篇文章与其他文章区分开来，那么这个词的权重越高。 计算公式TF计算： （markdown编辑数学公式还不怎么熟，先用mathtype搞好再截图吧）比如上面的例子，’水果’，’硬盘’在文章1中出现的次数分别为2次，4次，那么:12TF(水果) = 2/10 = 0.2 TF(硬盘) = 4/10 = 0.4 IDF计算： 如果这10篇文章中，有2篇文章包含有’水果’这个词，有5篇包含’硬盘’这个词，那么：12IDF(水果) = log(10/2) = 1.6094 IDF(硬盘) = log(10/5) = 0.6931 TF-IDF计算算好TF和IDF之后，就可以计算’水果’和’硬盘’的TF-IDF了，只需要将TF和IDF相乘就ok。所以’水果’的TF-IDF为：10.2*1.6094 ‘硬盘’的TF-IDF为：10.4*0.6931 如果算’水果’和’硬盘’这两个词与文章1的相关性呢，很简单，只要将这两个词的TF-IDF加起来。10.2*1.6094 + 0.4*0.6931 python中计算TF-IDF使用的工具 jieba scikit-learn 切词其实切词只是计算TF-IDF的前期准备工作，在对中文文本进行TF-IDF计算的话，切词这一步应该是怎么也逃不过去了。平常工作中基本都是用jieba切词，这里也打算用jieba对文本进行处理。例如我现在有5个文本：1content = [['萨德系统核心装备X波段雷达'],['美韩当局部署萨德的步伐也在加速进行'],['纵观如今的手机处理器市场已经不是高通一家独大的局面'],['三星的Exynos处理器以及华为的海思麒麟芯片这些年风头正盛'],['魅族每年数以千万计的销量对于芯片厂商的贡献也是不可小看的']] 首先需要对文本进行切词，切词代码及结果如下：1234567891011def cut_words(text): results = [] for content in contents: seg_list = jieba.cut(content[0],cut_all=False) # 实际应用过程中，这里需要去除停用词 seg = ' '.join(seg_list) results.append(seg) return resultsresult = cut_words(contents)result = ['萨德 系统核心 装备 X 波段 雷达', '美韩 当局 部署 萨德 的 步伐 也 在 加速 进行', '纵观 如今 的 手机 处理器 市场 已经 不是 高通 一家独大 的 局面', '三星 的 Exynos 处理器 以及 华为 的 海思 麒麟 芯片 这些 年 风头 正 盛', '魅族 每年 数以千万计 的 销量 对于 芯片 厂商 的 贡献 也 是 不可 小看 的'] 准备工作做好之后，我们就可以进行TF-IDF计算了。 词语转矩阵词语转矩阵需要用到CountVectorizer这个函数，其作用是统计词汇的数量，并转为矩阵。1234#coding:utf-8from sklearn.feature_extraction.text import CountVectorizervectorizer = CountVectorizer()vector_location = vectorizer.fit_transform(result) 通过type(vector_location)可以看到，函数fit_transform把result二维数组表示成一个稀疏矩阵:123print(type(vector_location))#输出&lt;class 'scipy.sparse.csr.csr_matrix'&gt; 同时可以看下，vercot_location的输出结果：1234567891011121314151617181920212223242526272829303132333435363738394041424344print(vector_location)#输出#(0, 27) 1#(0, 23) 1#(0, 28) 1#(0, 21) 1#(0, 34) 1#(1, 27) 1#(1, 25) 1#(1, 16) 1#(1, 32) 1#(1, 19) 1#(1, 6) 1#(1, 31) 1#(2, 24) 1#(2, 10) 1#(2, 17) 1#(2, 9) 1#(2, 15) 1#(2, 14) 1#(2, 4) 1#(2, 36) 1#(2, 1) 1#(2, 13) 1#(3, 9) 1#(3, 2) 1#(3, 0) 1#(3, 5) 1#(3, 7) 1#(3, 22) 1#(3, 38) 1#(3, 26) 1#(3, 30) 1#(3, 35) 1#(4, 26) 1#(4, 37) 1#(4, 20) 1#(4, 18) 1#(4, 33) 1#(4, 11) 1#(4, 8) 1#(4, 29) 1#(4, 3) 1#(4, 12) 1 输出结果表示的是这个稀疏矩阵的第几行第几列有值，比如(0, 27) 1表示矩阵的第0行第27列有值。转成矩阵的形式之后，我们就可以很容易地算出每个词对应的TF-IDF了，这里使用TfidfTransformer函数进行计算。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from sklearn.feature_extraction.text import TfidfTransformertransformer = TfidfTransformer()tf_idf = transformer.fit_transform(vector_location)print(type(tf_idf))#输出，同样是稀疏矩阵的形式#&lt;class 'scipy.sparse.csr.csr_matrix'&gt;print(tf_idf)#输出#(0, 34) 0.463693222732#(0, 21) 0.463693222732#(0, 28) 0.463693222732#(0, 23) 0.463693222732#(0, 27) 0.37410477245#(1, 31) 0.387756660106#(1, 6) 0.387756660106#(1, 19) 0.387756660106#(1, 32) 0.387756660106#(1, 16) 0.387756660106#(1, 25) 0.387756660106#(1, 27) 0.312839631859#(2, 13) 0.321896111462#(2, 1) 0.321896111462#(2, 36) 0.321896111462#(2, 4) 0.321896111462#(2, 14) 0.321896111462#(2, 15) 0.321896111462#(2, 9) 0.259703755905#(2, 17) 0.321896111462#(2, 10) 0.321896111462#(2, 24) 0.321896111462#(3, 35) 0.327880622184#(3, 30) 0.327880622184#(3, 26) 0.264532021474#(3, 38) 0.327880622184#(3, 22) 0.327880622184#(3, 7) 0.327880622184#(3, 5) 0.327880622184#(3, 0) 0.327880622184#(3, 2) 0.327880622184#(3, 9) 0.264532021474#(4, 12) 0.321896111462#(4, 3) 0.321896111462#(4, 29) 0.321896111462#(4, 8) 0.321896111462#(4, 11) 0.321896111462#(4, 33) 0.321896111462#(4, 18) 0.321896111462#(4, 20) 0.321896111462#(4, 37) 0.321896111462#(4, 26) 0.259703755905 做到这一步的话还差一点点，因为在实际应用过程中，我们还需要把稀疏矩阵转成平常用的行列形式的矩阵才方便使用。这里可以使用todense()或者toarray()函数，前者是将稀疏矩阵转成matrix的形式，后者是将稀疏矩阵转成ndarray的形式1234567weight = tf_idf.toarray()#orweight1 = tf_idf.todense()print(weight)#输出#(5,39) 其实print一下weight的shape可以看到，这是一个5行39列的数组，5代表5个文本，39代表切词并用于计算的词的数量。如果文本的数量很大，切出来的词有很多的话，你很有可能会遇到MemoryError的错误，比如有1万个文本，切词3万个，那么数组（矩阵）的大小就变成了(10000,30000)，这样就会变得极其稀疏。对于大数据量的文本在计算TF-IDF时遇到MemoryError时，除了加内存或者上服务器之外，目前尚未找到更好的解决办法。这里还有一个问题，就是我怎么知道每个权重对应的是哪个词呢？这里可以将词作为列名，将数组转成Dataframe进行查看。1234word=vectorizer.get_feature_names()df = pd.DataFrame(weight)df.columns = wordprint(df) 源代码最后照例附上本次分析的源代码123456789101112131415161718192021222324252627282930313233343536#coding:utf-8#author:linchartimport jiebaimport pandas as pdfrom sklearn.feature_extraction.text import CountVectorizerfrom sklearn.feature_extraction.text import TfidfTransformercontents = [['萨德系统核心装备X波段雷达'],\\ ['美韩当局部署萨德的步伐也在加速进行'],\\ ['纵观如今的手机处理器市场已经不是高通一家独大的局面'],\\ ['三星的Exynos处理器以及华为的海思麒麟芯片这些年风头正盛'],\\ ['魅族每年数以千万计的销量对于芯片厂商的贡献也是不可小看的']]def cut_words(text): results = [] for content in contents: seg_list = jieba.cut(content[0],cut_all=False) # 实际应用过程中，这里需要去除停用词 seg = ' '.join(seg_list) results.append(seg) return resultsdef tf_idf(words): vectorizer = CountVectorizer() vector_location = vectorizer.fit_transform(result) transformer = TfidfTransformer() tf_idf = transformer.fit_transform(vector_location) weight = tf_idf.toarray() word = vectorizer.get_feature_names() df = pd.DataFrame(weight) df.columns = word return dfresult = cut_words(contents)df = tf_idf(result)print(df)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"NLP","slug":"NLP","permalink":"http://yoursite.com/tags/NLP/"}]},{"title":"爬取微信文章（一）","date":"2017-03-13T09:59:18.349Z","path":"posts/2017/03/13/WeChat_Article1.html","text":"&emsp;&emsp;有时在微信公众号上面看到一些写的比较好的文章，但又没有时间细看，闲下来想找这些文章的时候又忘了是在哪个公众号看的了、文章名字也想不起来，因此想搞个爬虫把想看的文章爬下来，一来可以在闲时咀嚼一下，二来也可以收藏一些好文章，做些知识积累。只是想把自己平常做的一些东西记录下来，非教程 工具 Python 3.5.1 使用的库 re pdfkit requests BeautifulSoup 功能输入微信文章名称或者对应的文章链接，输出文章的pdf文件。 思路 如果同时提供文章链接和文章名称，则优先通过文章链接爬取，如果文章链接爬取失败，则通过文章名称爬取； 如果仅提供文章链接，则通过文章链接爬取； 如果仅提供文章名称，则通过搜狗微信接口搜索微信文章，找到对应文章链接，然后在通过文章链接爬取。 爬取流程获取文章链接将提供的文章名称传入搜狗微信搜索引擎搜索，将结果列表中的第一篇文章作为目标文章下载。下面代码返回目标文章链接。 12345678910111213def get_article_link(query): base_url = r'http://weixin.sogou.com/weixin' User_Agent = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36' Host = 'weixin.sogou.com' Connection = 'keep-alive' headers = &#123;'User-Agent': User_Agent, 'Host': Host, 'Connection': Connection&#125; params = &#123;'type': 2, 'ie': 'utf-8', 'w': '01019900', 'sut': '707','query':query&#125; request = requests.get(base_url, headers=headers, params=params) request.encoding = 'utf-8' bsobj = BeautifulSoup(request.text, 'lxml') # 仅提取列表中的第一篇文章 first_article_link = bsobj.select('#sogou_vr_11002601_title_0')[0]['href'] return first_article_link 将文章转为html解析文章链接，将文章内容保存为html文件。这里需要注意的是，在解析文章的时候，如果文章中包含有图片的话，正常情况下是无法下载下来的，因为爬取的文章链接为临时链接，非永久链接，无法直接解析src里面的链接。但是，data-src这个属性的值还是可以解析出来的，所以只要把data-src替换为src就可以下载图片了。 12345678910111213141516171819def get_article_html(link): # 为了保险起见，这里使用不同的headers User_Agent = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/3.0 Safari/536.11' article_headers = &#123;'User_Agent': User_Agent&#125; article_obj = requests.get(link, headers=article_headers) article_obj.encoding = 'utf-8' soup = BeautifulSoup(article_obj.content, 'html5lib') # 以实际的文章名称为准 article_name = soup.select('#activity-name')[0].text.strip() content = soup.find('div', &#123;'id': 'page-content'&#125;) html = str(content) # 把属性data-src替换成src,前面无法将属性src解析出来，data-src，只是LAZY用的， # 延迟加载图片所以显示不出来，LAZYLOAD src_compile = re.compile('data-src') html_new = re.sub(src_compile, 'src', html) # 存储成html with open('wechat_article.html', 'w', encoding='GB18030') as f: f.write(html_new) return article_name html转pdfhtml文件转pdf调用了pdfkit这个包，使用这个包需要安装wkhtmltopdf软件（pdfkit依赖于wkhtmltopdf，因此需要配置路径）。在运行过程中，发现pdfkit在html转pdf时，生成的pdf文件名中如果包含有| / *这些特殊符号时会报错，因此如果以原文章名对pdf命名失败时，仅保留文章名的汉字、字母和数字进行命名。 1234567891011121314151617def html_to_pdf(query_article): path_wk = r'D:\\Program Files\\wkhtmltopdf\\bin\\wkhtmltopdf.exe' config = pdfkit.configuration(wkhtmltopdf=path_wk) options = &#123; 'page-size': 'Letter', 'encoding': \"GB18030\", 'custom-header': [ ('Accept-Encoding', 'gzip') ] &#125; try : pdfkit.from_file('wechat_article.html', '%s.pdf' % query_article, configuration=config, options=options) except: name_compile = re.compile('[a-zA-Z\\u4e00-\\u9fa5][a-zA-Z0-9\\u4e00-\\u9fa5]+') pdf_name = re.findall(name_compile,query_article)[0] pdfkit.from_file('wechat_article.html', '%s.pdf' % pdf_name, configuration=config, options=options) print('文件名已被修改为:%s' %pdf_name) 源代码最后附上文章爬取的完整代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding:utf-8#author:linchartimport requestsfrom bs4 import BeautifulSoupimport reimport pdfkitdef get_article_link(query): base_url = r'http://weixin.sogou.com/weixin' User_Agent = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36' Host = 'weixin.sogou.com' Connection = 'keep-alive' headers = &#123;'User-Agent': User_Agent, 'Host': Host, 'Connection': Connection&#125; params = &#123;'type': 2, 'ie': 'utf-8', 'w': '01019900', 'sut': '707','query':query&#125; request = requests.get(base_url, headers=headers, params=params) request.encoding = 'utf-8' bsobj = BeautifulSoup(request.text, 'lxml') # 仅提取列表中的第一篇文章 first_article_link = bsobj.select('#sogou_vr_11002601_title_0')[0]['href'] return first_article_linkdef get_article_html(link): # 需要不同的headers User_Agent = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/3.0 Safari/536.11' article_headers = &#123;'User_Agent': User_Agent&#125; article_obj = requests.get(link, headers=article_headers) article_obj.encoding = 'utf-8' soup = BeautifulSoup(article_obj.content, 'html5lib') # 以实际的文章名称为准 article_name = soup.select('#activity-name')[0].text.strip() content = soup.find('div', &#123;'id': 'page-content'&#125;) html = str(content) # 把属性data-src替换成src,前面无法将属性src解析出来，data-src，只是LAZY用的， # 延迟加载图片所以显示不出来，LAZYLOAD src_compile = re.compile('data-src') html_new = re.sub(src_compile, 'src', html) # 存储成html with open('wechat_article.html', 'w', encoding='GB18030') as f: f.write(html_new) return article_namedef html_to_pdf(query_article): path_wk = r'D:\\Program Files\\wkhtmltopdf\\bin\\wkhtmltopdf.exe' config = pdfkit.configuration(wkhtmltopdf=path_wk) options = &#123; 'page-size': 'Letter', 'encoding': \"GB18030\", 'custom-header': [ ('Accept-Encoding', 'gzip') ] &#125; try : pdfkit.from_file('wechat_article.html', '%s.pdf' % query_article, configuration=config, options=options) except: name_compile = re.compile('[a-zA-Z\\u4e00-\\u9fa5][a-zA-Z0-9\\u4e00-\\u9fa5]+') pdf_name = re.findall(name_compile,query_article)[0] pdfkit.from_file('wechat_article.html', '%s.pdf' % pdf_name, configuration=config, options=options) print('文件名已被修改为:%s' %pdf_name)def wechat_article(query=None,link=None): if link : try : article_name = get_article_html(link) html_to_pdf(article_name) print('文章下载成功') except : article_link = get_article_link(query) get_article_html(article_link) html_to_pdf(query) print('文章下载成功') else : article_link = get_article_link(query) get_article_html(article_link) html_to_pdf(query) print('文章下载成功')# PDF可以用中文命名，但是命名中不可以包含* \\/|等特殊字符。if __name__ == '__main__': link = None query = '文本分析|词频与余弦相似度' wechat_article(query=query,link=link)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"}]},{"title":"博客的搭建","date":"2017-03-04T18:08:32.626Z","path":"posts/2017/03/05/blog.html","text":"参考文档这个博客的搭建，完全得益于教你免费搭建个人博客，Hexo&amp;Github和使用GitHub和Hexo搭建免费静态Blog这两篇文章，非常详细地描述了基于hexo+github搭建个人博客的准备工作及安装和配置流程。 遇到的问题虽然上面这两篇文章写得很详细，但是我在按着教程搭建的过程中还是遇到一些小问题，这里记录一下： 1、注意运行路径在浏览器中查看自带的hello world文章，需要执行 hexo generate 和hexo server两个命令，这里要注意一下这两个命令的执行路径，需要在hello world文章路径下执行。 2、MarkdownPad无法预览win10下首次安装MarkdownPad会出现右侧浏览页面无法浏览的情况，这种情况下需要安装Awesomium 1.6.6 SDK，安装完成之后问题可解决。 3、yilia主题头像无法显示若加载头像后，头像无法显示，需要将’themes/yilia/layout/_partial’路径下的文件left-col.ejs中的第6行修改为： &lt;img src=\"&lt;%=theme.avatar%&gt;\" class=\"js-avatar show\"&gt; 4、部署上传部署上传时执行以下命令时 hexo d 报’ERROR Deployer not found: git’错误，可能是deployer-git插件未安装，在根目录下执行下面代码安装该插件即可。 npm install hexo-deployer-git --save","tags":[]}]